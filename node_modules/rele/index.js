var irc = require('irc')

var errors = module.exports.errors = {
    duplicateNetwork:   "Already joined to that network",
    duplicateChannel:   "Already joined to that channel",
    unknownNetwork:     "Unknown network",
    unknownChannel:     "Unknown channel"
}

var callbacks = {}
var on = module.exports.on = function(eventName, callback) {
    callbacks[eventName] = callback
}
function emit(eventName, obj) {
    if (eventName in callbacks && typeof callbacks[eventName] === 'function') {
        console.info('Rele event: ' + eventName)
        return callbacks[eventName](obj)
    }
    return null
}

var currentNetwork = null,
    networks = []
var getCurrentNetwork = module.exports.getCurrentNetwork = function() {
    return currentNetwork
}
var setCurrentNetwork = module.exports.setCurrentNetwork = function(network) {
    currentNetwork = network
    emit('changeNetworks', {networks: networks})
}
var getNetworks = module.exports.getNetworks = function() {
    return networks
}

var getCurrentChannel = module.exports.getCurrentChannel = function() {
    return currentNetwork ? currentNetwork.currentChannel : null
}
var setCurrentChannel = module.exports.setCurrentChannel = function(channel) {
    var chan
    if (typeof channel === 'string') {
        chan = currentNetwork.getChannel(channel)
    } else {
        chan = channel
    }
    currentNetwork.previousChannel = currentNetwork.currentChannel || currentNetwork.systemChannel()
    currentNetwork.currentChannel = chan

    if (!chan.network.isCurrent()) {
        setCurrentNetwork(chan.network)
    }

    emit('changeChannels', {network: currentNetwork, channels: currentNetwork.channels})
}

var cleanUp = module.exports.cleanUp = function() {
    networks.forEach(function(network) {
        network.disconnect('', function(){})
    })
    currentNetwork = null
    networks = []
}

var eventNames = module.exports.eventNames = [
    'registered', 'motd', 'names', 'topic', 'join', 'part',
    'quit', 'kick', 'kill', 'message', 'message#',
    'selfMessage', 'notice', 'ping', 'pm', 'ctcp',
    'ctcp-notice', 'ctcp-privmsg', 'ctcp-version', 'nick',
    'invite', '+mode', '-mode', 'whois', 'channellist_start',
    'channellist_item', 'channellist', 'action', 'raw', 'error'
]

var Network = module.exports.Network = function(host, handle, options) {
    console.info('Rele: connecting ' + host)

    this.client             = new irc.Client(host, handle || process.env.USERNAME || process.env.LOGNAME || process.env.USER || 'Anon', options)
    this.handle             = handle
    this.host               = host
    this.options            = options
    this.connected          = false
    this.hasActivity        = false
    this.hasHighlight       = false
    this.channels           = [this.createSystemChannel()]
    this.currentChannel     = this.channels[0]
    this.previousChannel    = '_'
    this.logRaw             = false
    this.client.addListener('error', function(message) {
        console.error(message)
    })
    this.client.addListener('raw', function(message) {
        if (this.logRaw) {
            console.log(message)
        }
    })

    currentNetwork = this
    this.addListeners()
    networks.push(this)
    emit('changeNetworks', {networks: networks})
    emit('changeChannels', {network: this, channels: this.channels})
}
Network.prototype.createSystemChannel = function() {
    var chan = new Channel(this, '_')
    chan.canTalk = true
    return chan
}
Network.prototype.disconnect = function(message, callback) {
    for (var i = 0; i < networks.length; i++) {
        if (networks[i].host === this.host) {
            networks.splice(i, 1)
        }
    }
    currentNetwork = networks[0] || null
    this.client.disconnect(typeof message !== 'undefined' ? message : 'Leaving network', function() {
        emit('changeNetworks', {networks: networks})
        callback()
    })
}
Network.prototype.on = function(eventName, callback) {
    this.client.addListener(eventName, callback)
}
Network.prototype.getChannel = function(channelName) {
    for (var i = 0; i < this.channels.length; i++) {
        if (this.channels[i].name === channelName) {
            return this.channels[i]
        }
    }
    return null
}
Network.prototype.systemChannel = function() {
    return this.getChannel('_')
}
Network.prototype.isCurrent = function() {
    return (this.host === getCurrentNetwork().host)
}
Network.prototype.addListeners = function() {
    var that = this

    this.on('registered', function() {
        that.connected = true
        emit('changeNetworks', {networks: networks})
    })

    this.on('names', function(channel, names) {
        var chan = that.getChannel(channel)
        if (chan) {
            chan.setUsers(names)
        }
    })

    this.on('join', function(channel, handle, rawMessage) {
        var chan = that.getChannel(channel)
        if (chan) {
            chan.addUser(handle, '')

            var joinMessage = emit('join', {network: that, channel: chan, handle: handle})
            chan.pushMessage(joinMessage || new Message('', handle + ' ->', 'join'))
        }
    })

    this.on('part', function(channel, handle, reason, rawMessage) {
        var chan = that.getChannel(channel)
        if (chan) {
            chan.removeUser(handle)

            var partMessage = emit('part', {network: that, channel: chan, handle: handle, reason: reason})
            chan.pushMessage(partMessage || new Message('', '<-  ' + handle + ' (' + reason + ')', 'part'))
        }
    })

    this.on('quit', function(handle, reason, channels, rawMessage) {
        channels.forEach(function(channel) {
            var chan = that.getChannel(channel)
            if (chan) {
                chan.removeUser(handle)

                var quitMessage = emit('quit', {network: that, channel: chan, handle: handle, reason: reason})
                chan.pushMessage(quitMessage || new Message('', '<-- ' + handle + ' (' + reason + ')', 'quit'))
            }
        })
    })

    this.on('kick', function(channel, handle, by, reason, rawMessage) {
        var chan = that.getChannel(channel)
        if (chan) {
            chan.removeUser(handle)

            var kickMessage = emit('kick', {network: that, channel: chan, handle: handle, reason: reason})
            chan.pushMessage(kickMessage || new Message('', by + ' kicked ' + handle + ' (' + reason + ')', 'kick'))
        }
    })

    this.on('kill', function(handle, reason, channels, rawMessage) {
        channels.forEach(function(channel) {
            var chan = that.getChannel(channel)
            if (chan) {
                chan.removeUser(handle)

                var killMessage = emit('kill', {network: that, channel: chan, handle: handle, reason: reason})
                chan.pushMessage(killMessage || new Message('', 'RIP ' + handle + ' (' + reason + ')', 'kill'))
            }
        })
    })

    this.on('message#', function(handle, to, message, rawMessage) {
        var chan = that.getChannel(to)
        if (chan) {
            chan.pushMessage(new Message(handle, message, 'message'))

            if (emit('shouldHighlight', {network: that, channel: chan, handle: handle, message: message})) {
                chan.highlight(handle, message)
            }
        }
    })

    this.on('selfMessage', function(to, message) {
        var chan = that.getChannel(to)
        if (chan) {
            chan.pushMessage(new Message(that.client.nick, message, 'selfMessage'))
        }
    })

    this.on('pm', function(handle, message, rawMessage) {
        var chan = that.getChannel(handle)
        if (chan) {
            chan.pushMessage(new Message(handle, message, 'message'))

            chan.highlight(handle, message)
        } else {
            chan = new Channel(that, handle)
            chan.users[that.client.nick] = ''
            chan.users[handle] = ''
            chan.canTalk = true
            chan.private = true
            chan.pushMessage(new Message(handle, message, 'message'))

            that.channels.push(chan)
            emit('changeChannels', {network: that, channels: that.channels})

            chan.highlight(handle, message)
        }
    })

    this.on('motd', function(motd) {
        var chan = that.systemChannel()
        if (chan) {
            chan.pushMessage(new Message('', motd, 'motd'))
        }
    })

    this.on('notice', function(handle, to, message, rawMessage) {
        var chan = that.getChannel(to) || that.currentChannel
        if (chan) {
            chan.pushMessage(new Message(handle, message, 'notice'))
        }
    })

    this.on('whois', function(info) {
        var chan = that.currentChannel
        if (chan && 'server' in info) {
            for (var key in info) {
                if (info[key]) {
                    chan.pushMessage(new Message('', '[' + info.nick + '] ' + key + ': ' + info[key].toString()), 'whois')
                }
            }
        }
    })

    this.on('action', function(from, to, message, rawMessage) {
        var chan = that.getChannel(to)
        if (chan) {
            chan.pushMessage(new Message('', from + ' ' + message, 'action'))
        }
    })

    this.on('nick', function(oldHandle, newHandle, channels, rawMessage) {
        channels.forEach(function(channelName) {
            var chan = that.getChannel(channelName)
            if (chan) {
                chan.pushMessage(new Message('', oldHandle + ' is now known as ' + newHandle, 'nick'))

                emit('changeUsers', {network: that, channel: chan})
            }
        })
    })

    this.on('error', function(rawMessage) {
        var chan = that.currentChannel
        if (chan) {
            var errorMessage = emit('error', {network: that, rawMessage: rawMessage})
            chan.pushMessage(errorMessage || new Message('', rawMessage.args[2] + ': ' + rawMessage.args[1], 'error'))
        }
    })
}

var Channel = module.exports.Channel = function(network, channelName) {
    var channelNameParts = channelName.split(' ')
    this.network        = network || null
    this.name           = channelNameParts.shift()   || null
    this.pass           = channelNameParts.join(' ') || null
    this.users          = {}
    this.modes          = []
    this.log            = []
    this.canTalk        = false
    this.private        = false
    this.hasActivity    = false
    this.hasHighlight   = false
}
Channel.prototype.join = function(callback) {
    for (var i = 0; i < this.network.channels.length; i++) {
        if (this.network.channels[i].name === this.name) {
            throw errors.duplicateChannel
        }
    }

    if ('&#!+.~'.indexOf(this.name[0]) < 0) {
        this.private = true
        this.canTalk = true
        this.users[this.network.client.nick] = ''
        this.users[this.name] = ''
        this.network.channels.push(this)
        callback(this)
        return this
    }

    var that = this
    this.network.client.join(this.name + ' ' + this.pass, function() {
        if (that.name in that.network.client.chans && that.network.getChannel(that.name) === null) {
            that.canTalk = true
            that.network.channels.push(that)
            setCurrentChannel(that)
            emit('changeChannels', {network: that.network})
            callback(that)
        } else {
            // Join failed
            console.log(that.network.getChannel(that.name))
            console.log(that.name in that.network.client.chans)
        }
    })
    return this
}
Channel.prototype.part = function(message, callback) {
    var that = this
    var removeChan = function () {
        for (var i = 0; i < that.network.channels.length; i++) {
            if (that.network.channels[i].name === that.name) {
                that.network.channels.splice(i, 1)
                setCurrentChannel(this.network.previousChannel)
                callback()
                emit('changeChannels', {network: that.network})
                return
            }
        }
        throw errors.unknownChannel
    }

    if (this.private) {
        removeChan()
    } else {
        this.network.client.part(this.name, message, removeChan)
    }
}
Channel.prototype.say = function(message) {
    if (this.canTalk)
        this.network.client.say(this.name, message)
}
Channel.prototype.isCurrent = function () {
    return (this.network.isCurrent() && this.name === getCurrentChannel().name)
}
Channel.prototype.activity = function () {
    this.network.hasActivity = true
    this.hasActivity = true
    emit('activity', {network: this.network, channel: this})
}
Channel.prototype.highlight = function (handle, message) {
    this.network.hasHighlight = true
    this.hasHighlight = true
    emit('highlight', {network: this.network, channel: this, handle: handle, message: message})
}
Channel.prototype.visited = function () {
    this.network.hasHighlight = false
    this.hasHighlight = false
    this.network.hasActivity = false
    this.hasActivity = false
}
Channel.prototype.pushMessage = function(msg) {
    if (msg.timestamp) {
        this.log.push(msg)
        emit('changeLog', {network: this.network, channel: this})
        this.activity()
    }
}
Channel.prototype.setUsers = function(names) {
    this.users = names
    emit('changeUsers', {network: this.network, channel: this})
}
Channel.prototype.addUser = function(handle, mode) {
    this.users[handle] = mode
    emit('changeUsers', {network: this.network, channel: this})
}
Channel.prototype.removeUser = function(handle) {
    delete this.users[handle]
    emit('changeUsers', {network: this.network, channel: this})
}
Channel.prototype.flood = function() {
    var msg = new Message('', 'FLOOD', 'message')
    for (var i = 0; i < 100; i++) {
        this.pushMessage(msg)
    }
}

var Message = module.exports.Message = function(handle, message, type) {
    this.handle     = handle
    this.message    = message
    this.type       = type
    this.timestamp  = +new Date()
}
